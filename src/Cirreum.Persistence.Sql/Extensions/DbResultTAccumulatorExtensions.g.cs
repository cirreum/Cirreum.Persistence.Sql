// <auto-generated/>
// Generated by DbResultTAccumulatorExtensions.tt
// Do not modify manually - changes will be overwritten.
#nullable enable

namespace Cirreum.Persistence;

using Cirreum;

/// <summary>
/// Provides extension methods for accumulating multiple query results into tuples.
/// These methods enable composing independent queries while preserving the railway-oriented
/// programming pattern, short-circuiting on the first failure.
/// </summary>
/// <remarks>
/// <para>
/// Use <c>AndXxxAsync</c> methods when queries are independent (don't need prior results for parameters).
/// Use <c>ThenXxxAsync</c> methods when a query depends on the result of a prior operation.
/// </para>
/// <para>
/// Example usage:
/// <code>
/// var result = await ctx.GetAsync&lt;User&gt;(userSql, userId)
///     .AndGetOptionalAsync&lt;Prefs&gt;(prefsSql)
///     .AndQueryAnyAsync&lt;Order&gt;(ordersSql)
///     .Map((user, prefs, orders) =&gt; new Dashboard(
///         user,
///         prefs.Map(p =&gt; p.Theme).GetValueOrDefault("default"),
///         orders));
/// </code>
/// </para>
/// </remarks>
public static class DbResultTAccumulatorExtensions {

	#region AndGetAsync: T1 -> (T1, T2)

	/// <summary>
	/// Accumulates a required single row query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="key">A key associated with the query result, used in the NotFoundException if no row is found.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2)> AndGetAsync<T1, T2>(
		this DbResult<T1> first,
		string sql,
		object key)
		=> new(first.Context, AndGetAsyncCore<T1, T2>(first.Result, first.Context, sql, null, key));

	/// <summary>
	/// Accumulates a required single row query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <param name="key">A key associated with the query result, used in the NotFoundException if no row is found.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2)> AndGetAsync<T1, T2>(
		this DbResult<T1> first,
		string sql,
		object? parameters,
		object key)
		=> new(first.Context, AndGetAsyncCore<T1, T2>(first.Result, first.Context, sql, parameters, key));

	private static async Task<Result<(T1, T2)>> AndGetAsyncCore<T1, T2>(
		Task<Result<T1>> resultTask,
		DbContext context,
		string sql,
		object? parameters,
		object key) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.GetAsync<T2>(sql, parameters, key).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var v1 = r1.Value;
		return (v1, r2.Value);
	
	}

	#endregion

	#region AndGetOptionalAsync: T1 -> (T1, Optional<T2>)

	/// <summary>
	/// Accumulates an optional single row query result (fails if more than one row) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, Optional<T2>)> AndGetOptionalAsync<T1, T2>(
		this DbResult<T1> first,
		string sql)
		=> new(first.Context, AndGetOptionalAsyncCore<T1, T2>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates an optional single row query result (fails if more than one row) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, Optional<T2>)> AndGetOptionalAsync<T1, T2>(
		this DbResult<T1> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndGetOptionalAsyncCore<T1, T2>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, Optional<T2>)>> AndGetOptionalAsyncCore<T1, T2>(
		Task<Result<T1>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.GetOptionalAsync<T2>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var v1 = r1.Value;
		return (v1, r2.Value);
	
	}

	#endregion

	#region AndQueryOptionalAsync: T1 -> (T1, Optional<T2>)

	/// <summary>
	/// Accumulates the first row query result (takes first if multiple exist) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, Optional<T2>)> AndQueryOptionalAsync<T1, T2>(
		this DbResult<T1> first,
		string sql)
		=> new(first.Context, AndQueryOptionalAsyncCore<T1, T2>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates the first row query result (takes first if multiple exist) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, Optional<T2>)> AndQueryOptionalAsync<T1, T2>(
		this DbResult<T1> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndQueryOptionalAsyncCore<T1, T2>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, Optional<T2>)>> AndQueryOptionalAsyncCore<T1, T2>(
		Task<Result<T1>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.QueryOptionalAsync<T2>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var v1 = r1.Value;
		return (v1, r2.Value);
	
	}

	#endregion

	#region AndQueryAnyAsync: T1 -> (T1, IReadOnlyList<T2>)

	/// <summary>
	/// Accumulates a collection query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, IReadOnlyList<T2>)> AndQueryAnyAsync<T1, T2>(
		this DbResult<T1> first,
		string sql)
		=> new(first.Context, AndQueryAnyAsyncCore<T1, T2>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates a collection query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, IReadOnlyList<T2>)> AndQueryAnyAsync<T1, T2>(
		this DbResult<T1> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndQueryAnyAsyncCore<T1, T2>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, IReadOnlyList<T2>)>> AndQueryAnyAsyncCore<T1, T2>(
		Task<Result<T1>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.QueryAnyAsync<T2>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var v1 = r1.Value;
		return (v1, r2.Value);
	
	}

	#endregion

	#region AndGetScalarAsync: T1 -> (T1, T2)

	/// <summary>
	/// Accumulates a scalar query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2)> AndGetScalarAsync<T1, T2>(
		this DbResult<T1> first,
		string sql)
		=> new(first.Context, AndGetScalarAsyncCore<T1, T2>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates a scalar query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2)> AndGetScalarAsync<T1, T2>(
		this DbResult<T1> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndGetScalarAsyncCore<T1, T2>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2)>> AndGetScalarAsyncCore<T1, T2>(
		Task<Result<T1>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.GetScalarAsync<T2>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var v1 = r1.Value;
		return (v1, r2.Value);
	
	}

	#endregion

	#region AndGetAsync: (T1, T2) -> (T1, T2, T3)

	/// <summary>
	/// Accumulates a required single row query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="key">A key associated with the query result, used in the NotFoundException if no row is found.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3)> AndGetAsync<T1, T2, T3>(
		this DbResult<(T1, T2)> first,
		string sql,
		object key)
		=> new(first.Context, AndGetAsyncCore<T1, T2, T3>(first.Result, first.Context, sql, null, key));

	/// <summary>
	/// Accumulates a required single row query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <param name="key">A key associated with the query result, used in the NotFoundException if no row is found.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3)> AndGetAsync<T1, T2, T3>(
		this DbResult<(T1, T2)> first,
		string sql,
		object? parameters,
		object key)
		=> new(first.Context, AndGetAsyncCore<T1, T2, T3>(first.Result, first.Context, sql, parameters, key));

	private static async Task<Result<(T1, T2, T3)>> AndGetAsyncCore<T1, T2, T3>(
		Task<Result<(T1, T2)>> resultTask,
		DbContext context,
		string sql,
		object? parameters,
		object key) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.GetAsync<T3>(sql, parameters, key).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2) = r1.Value;
		return (v1, v2, r2.Value);
	
	}

	#endregion

	#region AndGetOptionalAsync: (T1, T2) -> (T1, T2, Optional<T3>)

	/// <summary>
	/// Accumulates an optional single row query result (fails if more than one row) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, Optional<T3>)> AndGetOptionalAsync<T1, T2, T3>(
		this DbResult<(T1, T2)> first,
		string sql)
		=> new(first.Context, AndGetOptionalAsyncCore<T1, T2, T3>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates an optional single row query result (fails if more than one row) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, Optional<T3>)> AndGetOptionalAsync<T1, T2, T3>(
		this DbResult<(T1, T2)> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndGetOptionalAsyncCore<T1, T2, T3>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2, Optional<T3>)>> AndGetOptionalAsyncCore<T1, T2, T3>(
		Task<Result<(T1, T2)>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.GetOptionalAsync<T3>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2) = r1.Value;
		return (v1, v2, r2.Value);
	
	}

	#endregion

	#region AndQueryOptionalAsync: (T1, T2) -> (T1, T2, Optional<T3>)

	/// <summary>
	/// Accumulates the first row query result (takes first if multiple exist) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, Optional<T3>)> AndQueryOptionalAsync<T1, T2, T3>(
		this DbResult<(T1, T2)> first,
		string sql)
		=> new(first.Context, AndQueryOptionalAsyncCore<T1, T2, T3>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates the first row query result (takes first if multiple exist) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, Optional<T3>)> AndQueryOptionalAsync<T1, T2, T3>(
		this DbResult<(T1, T2)> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndQueryOptionalAsyncCore<T1, T2, T3>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2, Optional<T3>)>> AndQueryOptionalAsyncCore<T1, T2, T3>(
		Task<Result<(T1, T2)>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.QueryOptionalAsync<T3>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2) = r1.Value;
		return (v1, v2, r2.Value);
	
	}

	#endregion

	#region AndQueryAnyAsync: (T1, T2) -> (T1, T2, IReadOnlyList<T3>)

	/// <summary>
	/// Accumulates a collection query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, IReadOnlyList<T3>)> AndQueryAnyAsync<T1, T2, T3>(
		this DbResult<(T1, T2)> first,
		string sql)
		=> new(first.Context, AndQueryAnyAsyncCore<T1, T2, T3>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates a collection query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, IReadOnlyList<T3>)> AndQueryAnyAsync<T1, T2, T3>(
		this DbResult<(T1, T2)> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndQueryAnyAsyncCore<T1, T2, T3>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2, IReadOnlyList<T3>)>> AndQueryAnyAsyncCore<T1, T2, T3>(
		Task<Result<(T1, T2)>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.QueryAnyAsync<T3>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2) = r1.Value;
		return (v1, v2, r2.Value);
	
	}

	#endregion

	#region AndGetScalarAsync: (T1, T2) -> (T1, T2, T3)

	/// <summary>
	/// Accumulates a scalar query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3)> AndGetScalarAsync<T1, T2, T3>(
		this DbResult<(T1, T2)> first,
		string sql)
		=> new(first.Context, AndGetScalarAsyncCore<T1, T2, T3>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates a scalar query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3)> AndGetScalarAsync<T1, T2, T3>(
		this DbResult<(T1, T2)> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndGetScalarAsyncCore<T1, T2, T3>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2, T3)>> AndGetScalarAsyncCore<T1, T2, T3>(
		Task<Result<(T1, T2)>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.GetScalarAsync<T3>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2) = r1.Value;
		return (v1, v2, r2.Value);
	
	}

	#endregion

	#region AndGetAsync: (T1, T2, T3) -> (T1, T2, T3, T4)

	/// <summary>
	/// Accumulates a required single row query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="key">A key associated with the query result, used in the NotFoundException if no row is found.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4)> AndGetAsync<T1, T2, T3, T4>(
		this DbResult<(T1, T2, T3)> first,
		string sql,
		object key)
		=> new(first.Context, AndGetAsyncCore<T1, T2, T3, T4>(first.Result, first.Context, sql, null, key));

	/// <summary>
	/// Accumulates a required single row query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <param name="key">A key associated with the query result, used in the NotFoundException if no row is found.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4)> AndGetAsync<T1, T2, T3, T4>(
		this DbResult<(T1, T2, T3)> first,
		string sql,
		object? parameters,
		object key)
		=> new(first.Context, AndGetAsyncCore<T1, T2, T3, T4>(first.Result, first.Context, sql, parameters, key));

	private static async Task<Result<(T1, T2, T3, T4)>> AndGetAsyncCore<T1, T2, T3, T4>(
		Task<Result<(T1, T2, T3)>> resultTask,
		DbContext context,
		string sql,
		object? parameters,
		object key) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.GetAsync<T4>(sql, parameters, key).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2, v3) = r1.Value;
		return (v1, v2, v3, r2.Value);
	
	}

	#endregion

	#region AndGetOptionalAsync: (T1, T2, T3) -> (T1, T2, T3, Optional<T4>)

	/// <summary>
	/// Accumulates an optional single row query result (fails if more than one row) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, Optional<T4>)> AndGetOptionalAsync<T1, T2, T3, T4>(
		this DbResult<(T1, T2, T3)> first,
		string sql)
		=> new(first.Context, AndGetOptionalAsyncCore<T1, T2, T3, T4>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates an optional single row query result (fails if more than one row) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, Optional<T4>)> AndGetOptionalAsync<T1, T2, T3, T4>(
		this DbResult<(T1, T2, T3)> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndGetOptionalAsyncCore<T1, T2, T3, T4>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2, T3, Optional<T4>)>> AndGetOptionalAsyncCore<T1, T2, T3, T4>(
		Task<Result<(T1, T2, T3)>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.GetOptionalAsync<T4>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2, v3) = r1.Value;
		return (v1, v2, v3, r2.Value);
	
	}

	#endregion

	#region AndQueryOptionalAsync: (T1, T2, T3) -> (T1, T2, T3, Optional<T4>)

	/// <summary>
	/// Accumulates the first row query result (takes first if multiple exist) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, Optional<T4>)> AndQueryOptionalAsync<T1, T2, T3, T4>(
		this DbResult<(T1, T2, T3)> first,
		string sql)
		=> new(first.Context, AndQueryOptionalAsyncCore<T1, T2, T3, T4>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates the first row query result (takes first if multiple exist) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, Optional<T4>)> AndQueryOptionalAsync<T1, T2, T3, T4>(
		this DbResult<(T1, T2, T3)> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndQueryOptionalAsyncCore<T1, T2, T3, T4>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2, T3, Optional<T4>)>> AndQueryOptionalAsyncCore<T1, T2, T3, T4>(
		Task<Result<(T1, T2, T3)>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.QueryOptionalAsync<T4>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2, v3) = r1.Value;
		return (v1, v2, v3, r2.Value);
	
	}

	#endregion

	#region AndQueryAnyAsync: (T1, T2, T3) -> (T1, T2, T3, IReadOnlyList<T4>)

	/// <summary>
	/// Accumulates a collection query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, IReadOnlyList<T4>)> AndQueryAnyAsync<T1, T2, T3, T4>(
		this DbResult<(T1, T2, T3)> first,
		string sql)
		=> new(first.Context, AndQueryAnyAsyncCore<T1, T2, T3, T4>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates a collection query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, IReadOnlyList<T4>)> AndQueryAnyAsync<T1, T2, T3, T4>(
		this DbResult<(T1, T2, T3)> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndQueryAnyAsyncCore<T1, T2, T3, T4>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2, T3, IReadOnlyList<T4>)>> AndQueryAnyAsyncCore<T1, T2, T3, T4>(
		Task<Result<(T1, T2, T3)>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.QueryAnyAsync<T4>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2, v3) = r1.Value;
		return (v1, v2, v3, r2.Value);
	
	}

	#endregion

	#region AndGetScalarAsync: (T1, T2, T3) -> (T1, T2, T3, T4)

	/// <summary>
	/// Accumulates a scalar query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4)> AndGetScalarAsync<T1, T2, T3, T4>(
		this DbResult<(T1, T2, T3)> first,
		string sql)
		=> new(first.Context, AndGetScalarAsyncCore<T1, T2, T3, T4>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates a scalar query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4)> AndGetScalarAsync<T1, T2, T3, T4>(
		this DbResult<(T1, T2, T3)> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndGetScalarAsyncCore<T1, T2, T3, T4>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2, T3, T4)>> AndGetScalarAsyncCore<T1, T2, T3, T4>(
		Task<Result<(T1, T2, T3)>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.GetScalarAsync<T4>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2, v3) = r1.Value;
		return (v1, v2, v3, r2.Value);
	
	}

	#endregion

	#region AndGetAsync: (T1, T2, T3, T4) -> (T1, T2, T3, T4, T5)

	/// <summary>
	/// Accumulates a required single row query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="key">A key associated with the query result, used in the NotFoundException if no row is found.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5)> AndGetAsync<T1, T2, T3, T4, T5>(
		this DbResult<(T1, T2, T3, T4)> first,
		string sql,
		object key)
		=> new(first.Context, AndGetAsyncCore<T1, T2, T3, T4, T5>(first.Result, first.Context, sql, null, key));

	/// <summary>
	/// Accumulates a required single row query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <param name="key">A key associated with the query result, used in the NotFoundException if no row is found.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5)> AndGetAsync<T1, T2, T3, T4, T5>(
		this DbResult<(T1, T2, T3, T4)> first,
		string sql,
		object? parameters,
		object key)
		=> new(first.Context, AndGetAsyncCore<T1, T2, T3, T4, T5>(first.Result, first.Context, sql, parameters, key));

	private static async Task<Result<(T1, T2, T3, T4, T5)>> AndGetAsyncCore<T1, T2, T3, T4, T5>(
		Task<Result<(T1, T2, T3, T4)>> resultTask,
		DbContext context,
		string sql,
		object? parameters,
		object key) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.GetAsync<T5>(sql, parameters, key).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2, v3, v4) = r1.Value;
		return (v1, v2, v3, v4, r2.Value);
	
	}

	#endregion

	#region AndGetOptionalAsync: (T1, T2, T3, T4) -> (T1, T2, T3, T4, Optional<T5>)

	/// <summary>
	/// Accumulates an optional single row query result (fails if more than one row) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, Optional<T5>)> AndGetOptionalAsync<T1, T2, T3, T4, T5>(
		this DbResult<(T1, T2, T3, T4)> first,
		string sql)
		=> new(first.Context, AndGetOptionalAsyncCore<T1, T2, T3, T4, T5>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates an optional single row query result (fails if more than one row) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, Optional<T5>)> AndGetOptionalAsync<T1, T2, T3, T4, T5>(
		this DbResult<(T1, T2, T3, T4)> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndGetOptionalAsyncCore<T1, T2, T3, T4, T5>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2, T3, T4, Optional<T5>)>> AndGetOptionalAsyncCore<T1, T2, T3, T4, T5>(
		Task<Result<(T1, T2, T3, T4)>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.GetOptionalAsync<T5>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2, v3, v4) = r1.Value;
		return (v1, v2, v3, v4, r2.Value);
	
	}

	#endregion

	#region AndQueryOptionalAsync: (T1, T2, T3, T4) -> (T1, T2, T3, T4, Optional<T5>)

	/// <summary>
	/// Accumulates the first row query result (takes first if multiple exist) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, Optional<T5>)> AndQueryOptionalAsync<T1, T2, T3, T4, T5>(
		this DbResult<(T1, T2, T3, T4)> first,
		string sql)
		=> new(first.Context, AndQueryOptionalAsyncCore<T1, T2, T3, T4, T5>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates the first row query result (takes first if multiple exist) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, Optional<T5>)> AndQueryOptionalAsync<T1, T2, T3, T4, T5>(
		this DbResult<(T1, T2, T3, T4)> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndQueryOptionalAsyncCore<T1, T2, T3, T4, T5>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2, T3, T4, Optional<T5>)>> AndQueryOptionalAsyncCore<T1, T2, T3, T4, T5>(
		Task<Result<(T1, T2, T3, T4)>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.QueryOptionalAsync<T5>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2, v3, v4) = r1.Value;
		return (v1, v2, v3, v4, r2.Value);
	
	}

	#endregion

	#region AndQueryAnyAsync: (T1, T2, T3, T4) -> (T1, T2, T3, T4, IReadOnlyList<T5>)

	/// <summary>
	/// Accumulates a collection query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, IReadOnlyList<T5>)> AndQueryAnyAsync<T1, T2, T3, T4, T5>(
		this DbResult<(T1, T2, T3, T4)> first,
		string sql)
		=> new(first.Context, AndQueryAnyAsyncCore<T1, T2, T3, T4, T5>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates a collection query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, IReadOnlyList<T5>)> AndQueryAnyAsync<T1, T2, T3, T4, T5>(
		this DbResult<(T1, T2, T3, T4)> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndQueryAnyAsyncCore<T1, T2, T3, T4, T5>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2, T3, T4, IReadOnlyList<T5>)>> AndQueryAnyAsyncCore<T1, T2, T3, T4, T5>(
		Task<Result<(T1, T2, T3, T4)>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.QueryAnyAsync<T5>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2, v3, v4) = r1.Value;
		return (v1, v2, v3, v4, r2.Value);
	
	}

	#endregion

	#region AndGetScalarAsync: (T1, T2, T3, T4) -> (T1, T2, T3, T4, T5)

	/// <summary>
	/// Accumulates a scalar query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5)> AndGetScalarAsync<T1, T2, T3, T4, T5>(
		this DbResult<(T1, T2, T3, T4)> first,
		string sql)
		=> new(first.Context, AndGetScalarAsyncCore<T1, T2, T3, T4, T5>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates a scalar query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5)> AndGetScalarAsync<T1, T2, T3, T4, T5>(
		this DbResult<(T1, T2, T3, T4)> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndGetScalarAsyncCore<T1, T2, T3, T4, T5>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2, T3, T4, T5)>> AndGetScalarAsyncCore<T1, T2, T3, T4, T5>(
		Task<Result<(T1, T2, T3, T4)>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.GetScalarAsync<T5>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2, v3, v4) = r1.Value;
		return (v1, v2, v3, v4, r2.Value);
	
	}

	#endregion

	#region AndGetAsync: (T1, T2, T3, T4, T5) -> (T1, T2, T3, T4, T5, T6)

	/// <summary>
	/// Accumulates a required single row query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of element 5 in the source tuple.</typeparam>
	/// <typeparam name="T6">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="key">A key associated with the query result, used in the NotFoundException if no row is found.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5, T6)> AndGetAsync<T1, T2, T3, T4, T5, T6>(
		this DbResult<(T1, T2, T3, T4, T5)> first,
		string sql,
		object key)
		=> new(first.Context, AndGetAsyncCore<T1, T2, T3, T4, T5, T6>(first.Result, first.Context, sql, null, key));

	/// <summary>
	/// Accumulates a required single row query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of element 5 in the source tuple.</typeparam>
	/// <typeparam name="T6">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <param name="key">A key associated with the query result, used in the NotFoundException if no row is found.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5, T6)> AndGetAsync<T1, T2, T3, T4, T5, T6>(
		this DbResult<(T1, T2, T3, T4, T5)> first,
		string sql,
		object? parameters,
		object key)
		=> new(first.Context, AndGetAsyncCore<T1, T2, T3, T4, T5, T6>(first.Result, first.Context, sql, parameters, key));

	private static async Task<Result<(T1, T2, T3, T4, T5, T6)>> AndGetAsyncCore<T1, T2, T3, T4, T5, T6>(
		Task<Result<(T1, T2, T3, T4, T5)>> resultTask,
		DbContext context,
		string sql,
		object? parameters,
		object key) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.GetAsync<T6>(sql, parameters, key).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2, v3, v4, v5) = r1.Value;
		return (v1, v2, v3, v4, v5, r2.Value);
	
	}

	#endregion

	#region AndGetOptionalAsync: (T1, T2, T3, T4, T5) -> (T1, T2, T3, T4, T5, Optional<T6>)

	/// <summary>
	/// Accumulates an optional single row query result (fails if more than one row) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of element 5 in the source tuple.</typeparam>
	/// <typeparam name="T6">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5, Optional<T6>)> AndGetOptionalAsync<T1, T2, T3, T4, T5, T6>(
		this DbResult<(T1, T2, T3, T4, T5)> first,
		string sql)
		=> new(first.Context, AndGetOptionalAsyncCore<T1, T2, T3, T4, T5, T6>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates an optional single row query result (fails if more than one row) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of element 5 in the source tuple.</typeparam>
	/// <typeparam name="T6">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5, Optional<T6>)> AndGetOptionalAsync<T1, T2, T3, T4, T5, T6>(
		this DbResult<(T1, T2, T3, T4, T5)> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndGetOptionalAsyncCore<T1, T2, T3, T4, T5, T6>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2, T3, T4, T5, Optional<T6>)>> AndGetOptionalAsyncCore<T1, T2, T3, T4, T5, T6>(
		Task<Result<(T1, T2, T3, T4, T5)>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.GetOptionalAsync<T6>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2, v3, v4, v5) = r1.Value;
		return (v1, v2, v3, v4, v5, r2.Value);
	
	}

	#endregion

	#region AndQueryOptionalAsync: (T1, T2, T3, T4, T5) -> (T1, T2, T3, T4, T5, Optional<T6>)

	/// <summary>
	/// Accumulates the first row query result (takes first if multiple exist) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of element 5 in the source tuple.</typeparam>
	/// <typeparam name="T6">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5, Optional<T6>)> AndQueryOptionalAsync<T1, T2, T3, T4, T5, T6>(
		this DbResult<(T1, T2, T3, T4, T5)> first,
		string sql)
		=> new(first.Context, AndQueryOptionalAsyncCore<T1, T2, T3, T4, T5, T6>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates the first row query result (takes first if multiple exist) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of element 5 in the source tuple.</typeparam>
	/// <typeparam name="T6">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5, Optional<T6>)> AndQueryOptionalAsync<T1, T2, T3, T4, T5, T6>(
		this DbResult<(T1, T2, T3, T4, T5)> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndQueryOptionalAsyncCore<T1, T2, T3, T4, T5, T6>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2, T3, T4, T5, Optional<T6>)>> AndQueryOptionalAsyncCore<T1, T2, T3, T4, T5, T6>(
		Task<Result<(T1, T2, T3, T4, T5)>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.QueryOptionalAsync<T6>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2, v3, v4, v5) = r1.Value;
		return (v1, v2, v3, v4, v5, r2.Value);
	
	}

	#endregion

	#region AndQueryAnyAsync: (T1, T2, T3, T4, T5) -> (T1, T2, T3, T4, T5, IReadOnlyList<T6>)

	/// <summary>
	/// Accumulates a collection query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of element 5 in the source tuple.</typeparam>
	/// <typeparam name="T6">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5, IReadOnlyList<T6>)> AndQueryAnyAsync<T1, T2, T3, T4, T5, T6>(
		this DbResult<(T1, T2, T3, T4, T5)> first,
		string sql)
		=> new(first.Context, AndQueryAnyAsyncCore<T1, T2, T3, T4, T5, T6>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates a collection query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of element 5 in the source tuple.</typeparam>
	/// <typeparam name="T6">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5, IReadOnlyList<T6>)> AndQueryAnyAsync<T1, T2, T3, T4, T5, T6>(
		this DbResult<(T1, T2, T3, T4, T5)> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndQueryAnyAsyncCore<T1, T2, T3, T4, T5, T6>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2, T3, T4, T5, IReadOnlyList<T6>)>> AndQueryAnyAsyncCore<T1, T2, T3, T4, T5, T6>(
		Task<Result<(T1, T2, T3, T4, T5)>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.QueryAnyAsync<T6>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2, v3, v4, v5) = r1.Value;
		return (v1, v2, v3, v4, v5, r2.Value);
	
	}

	#endregion

	#region AndGetScalarAsync: (T1, T2, T3, T4, T5) -> (T1, T2, T3, T4, T5, T6)

	/// <summary>
	/// Accumulates a scalar query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of element 5 in the source tuple.</typeparam>
	/// <typeparam name="T6">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5, T6)> AndGetScalarAsync<T1, T2, T3, T4, T5, T6>(
		this DbResult<(T1, T2, T3, T4, T5)> first,
		string sql)
		=> new(first.Context, AndGetScalarAsyncCore<T1, T2, T3, T4, T5, T6>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates a scalar query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of element 5 in the source tuple.</typeparam>
	/// <typeparam name="T6">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5, T6)> AndGetScalarAsync<T1, T2, T3, T4, T5, T6>(
		this DbResult<(T1, T2, T3, T4, T5)> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndGetScalarAsyncCore<T1, T2, T3, T4, T5, T6>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2, T3, T4, T5, T6)>> AndGetScalarAsyncCore<T1, T2, T3, T4, T5, T6>(
		Task<Result<(T1, T2, T3, T4, T5)>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.GetScalarAsync<T6>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2, v3, v4, v5) = r1.Value;
		return (v1, v2, v3, v4, v5, r2.Value);
	
	}

	#endregion

	#region AndGetAsync: (T1, T2, T3, T4, T5, T6) -> (T1, T2, T3, T4, T5, T6, T7)

	/// <summary>
	/// Accumulates a required single row query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of element 5 in the source tuple.</typeparam>
	/// <typeparam name="T6">The type of element 6 in the source tuple.</typeparam>
	/// <typeparam name="T7">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="key">A key associated with the query result, used in the NotFoundException if no row is found.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5, T6, T7)> AndGetAsync<T1, T2, T3, T4, T5, T6, T7>(
		this DbResult<(T1, T2, T3, T4, T5, T6)> first,
		string sql,
		object key)
		=> new(first.Context, AndGetAsyncCore<T1, T2, T3, T4, T5, T6, T7>(first.Result, first.Context, sql, null, key));

	/// <summary>
	/// Accumulates a required single row query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of element 5 in the source tuple.</typeparam>
	/// <typeparam name="T6">The type of element 6 in the source tuple.</typeparam>
	/// <typeparam name="T7">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <param name="key">A key associated with the query result, used in the NotFoundException if no row is found.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5, T6, T7)> AndGetAsync<T1, T2, T3, T4, T5, T6, T7>(
		this DbResult<(T1, T2, T3, T4, T5, T6)> first,
		string sql,
		object? parameters,
		object key)
		=> new(first.Context, AndGetAsyncCore<T1, T2, T3, T4, T5, T6, T7>(first.Result, first.Context, sql, parameters, key));

	private static async Task<Result<(T1, T2, T3, T4, T5, T6, T7)>> AndGetAsyncCore<T1, T2, T3, T4, T5, T6, T7>(
		Task<Result<(T1, T2, T3, T4, T5, T6)>> resultTask,
		DbContext context,
		string sql,
		object? parameters,
		object key) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.GetAsync<T7>(sql, parameters, key).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2, v3, v4, v5, v6) = r1.Value;
		return (v1, v2, v3, v4, v5, v6, r2.Value);
	
	}

	#endregion

	#region AndGetOptionalAsync: (T1, T2, T3, T4, T5, T6) -> (T1, T2, T3, T4, T5, T6, Optional<T7>)

	/// <summary>
	/// Accumulates an optional single row query result (fails if more than one row) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of element 5 in the source tuple.</typeparam>
	/// <typeparam name="T6">The type of element 6 in the source tuple.</typeparam>
	/// <typeparam name="T7">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5, T6, Optional<T7>)> AndGetOptionalAsync<T1, T2, T3, T4, T5, T6, T7>(
		this DbResult<(T1, T2, T3, T4, T5, T6)> first,
		string sql)
		=> new(first.Context, AndGetOptionalAsyncCore<T1, T2, T3, T4, T5, T6, T7>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates an optional single row query result (fails if more than one row) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of element 5 in the source tuple.</typeparam>
	/// <typeparam name="T6">The type of element 6 in the source tuple.</typeparam>
	/// <typeparam name="T7">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5, T6, Optional<T7>)> AndGetOptionalAsync<T1, T2, T3, T4, T5, T6, T7>(
		this DbResult<(T1, T2, T3, T4, T5, T6)> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndGetOptionalAsyncCore<T1, T2, T3, T4, T5, T6, T7>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2, T3, T4, T5, T6, Optional<T7>)>> AndGetOptionalAsyncCore<T1, T2, T3, T4, T5, T6, T7>(
		Task<Result<(T1, T2, T3, T4, T5, T6)>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.GetOptionalAsync<T7>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2, v3, v4, v5, v6) = r1.Value;
		return (v1, v2, v3, v4, v5, v6, r2.Value);
	
	}

	#endregion

	#region AndQueryOptionalAsync: (T1, T2, T3, T4, T5, T6) -> (T1, T2, T3, T4, T5, T6, Optional<T7>)

	/// <summary>
	/// Accumulates the first row query result (takes first if multiple exist) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of element 5 in the source tuple.</typeparam>
	/// <typeparam name="T6">The type of element 6 in the source tuple.</typeparam>
	/// <typeparam name="T7">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5, T6, Optional<T7>)> AndQueryOptionalAsync<T1, T2, T3, T4, T5, T6, T7>(
		this DbResult<(T1, T2, T3, T4, T5, T6)> first,
		string sql)
		=> new(first.Context, AndQueryOptionalAsyncCore<T1, T2, T3, T4, T5, T6, T7>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates the first row query result (takes first if multiple exist) into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of element 5 in the source tuple.</typeparam>
	/// <typeparam name="T6">The type of element 6 in the source tuple.</typeparam>
	/// <typeparam name="T7">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5, T6, Optional<T7>)> AndQueryOptionalAsync<T1, T2, T3, T4, T5, T6, T7>(
		this DbResult<(T1, T2, T3, T4, T5, T6)> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndQueryOptionalAsyncCore<T1, T2, T3, T4, T5, T6, T7>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2, T3, T4, T5, T6, Optional<T7>)>> AndQueryOptionalAsyncCore<T1, T2, T3, T4, T5, T6, T7>(
		Task<Result<(T1, T2, T3, T4, T5, T6)>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.QueryOptionalAsync<T7>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2, v3, v4, v5, v6) = r1.Value;
		return (v1, v2, v3, v4, v5, v6, r2.Value);
	
	}

	#endregion

	#region AndQueryAnyAsync: (T1, T2, T3, T4, T5, T6) -> (T1, T2, T3, T4, T5, T6, IReadOnlyList<T7>)

	/// <summary>
	/// Accumulates a collection query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of element 5 in the source tuple.</typeparam>
	/// <typeparam name="T6">The type of element 6 in the source tuple.</typeparam>
	/// <typeparam name="T7">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5, T6, IReadOnlyList<T7>)> AndQueryAnyAsync<T1, T2, T3, T4, T5, T6, T7>(
		this DbResult<(T1, T2, T3, T4, T5, T6)> first,
		string sql)
		=> new(first.Context, AndQueryAnyAsyncCore<T1, T2, T3, T4, T5, T6, T7>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates a collection query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of element 5 in the source tuple.</typeparam>
	/// <typeparam name="T6">The type of element 6 in the source tuple.</typeparam>
	/// <typeparam name="T7">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5, T6, IReadOnlyList<T7>)> AndQueryAnyAsync<T1, T2, T3, T4, T5, T6, T7>(
		this DbResult<(T1, T2, T3, T4, T5, T6)> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndQueryAnyAsyncCore<T1, T2, T3, T4, T5, T6, T7>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2, T3, T4, T5, T6, IReadOnlyList<T7>)>> AndQueryAnyAsyncCore<T1, T2, T3, T4, T5, T6, T7>(
		Task<Result<(T1, T2, T3, T4, T5, T6)>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.QueryAnyAsync<T7>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2, v3, v4, v5, v6) = r1.Value;
		return (v1, v2, v3, v4, v5, v6, r2.Value);
	
	}

	#endregion

	#region AndGetScalarAsync: (T1, T2, T3, T4, T5, T6) -> (T1, T2, T3, T4, T5, T6, T7)

	/// <summary>
	/// Accumulates a scalar query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of element 5 in the source tuple.</typeparam>
	/// <typeparam name="T6">The type of element 6 in the source tuple.</typeparam>
	/// <typeparam name="T7">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5, T6, T7)> AndGetScalarAsync<T1, T2, T3, T4, T5, T6, T7>(
		this DbResult<(T1, T2, T3, T4, T5, T6)> first,
		string sql)
		=> new(first.Context, AndGetScalarAsyncCore<T1, T2, T3, T4, T5, T6, T7>(first.Result, first.Context, sql, null));

	/// <summary>
	/// Accumulates a scalar query result into the existing tuple.
	/// </summary>
	/// <typeparam name="T1">The type of element 1 in the source tuple.</typeparam>
	/// <typeparam name="T2">The type of element 2 in the source tuple.</typeparam>
	/// <typeparam name="T3">The type of element 3 in the source tuple.</typeparam>
	/// <typeparam name="T4">The type of element 4 in the source tuple.</typeparam>
	/// <typeparam name="T5">The type of element 5 in the source tuple.</typeparam>
	/// <typeparam name="T6">The type of element 6 in the source tuple.</typeparam>
	/// <typeparam name="T7">The type of the value to accumulate.</typeparam>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<(T1, T2, T3, T4, T5, T6, T7)> AndGetScalarAsync<T1, T2, T3, T4, T5, T6, T7>(
		this DbResult<(T1, T2, T3, T4, T5, T6)> first,
		string sql,
		object? parameters)
		=> new(first.Context, AndGetScalarAsyncCore<T1, T2, T3, T4, T5, T6, T7>(first.Result, first.Context, sql, parameters));

	private static async Task<Result<(T1, T2, T3, T4, T5, T6, T7)>> AndGetScalarAsyncCore<T1, T2, T3, T4, T5, T6, T7>(
		Task<Result<(T1, T2, T3, T4, T5, T6)>> resultTask,
		DbContext context,
		string sql,
		object? parameters) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.GetScalarAsync<T7>(sql, parameters).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

		var (v1, v2, v3, v4, v5, v6) = r1.Value;
		return (v1, v2, v3, v4, v5, v6, r2.Value);
	
	}

	#endregion

}