<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#
	const int MaxTupleSize = 7;
	
	string TypeParams(int count) => 
		string.Join(", ", Enumerable.Range(1, count).Select(i => $"T{i}"));
	
	string TupleType(int count) => 
		count == 1 ? "T1" : $"({TypeParams(count)})";
	
	string Deconstruct(int count) => 
		count == 1 
			? "v1" 
			: $"({string.Join(", ", Enumerable.Range(1, count).Select(i => $"v{i}"))})";
	
	string BuildTuple(int count) =>
		string.Join(", ", Enumerable.Range(1, count).Select(i => $"v{i}"));
	
	string NextTypeParam(int count) => $"T{count + 1}";

	// Define the query methods to generate And variants for
	// Format: (MethodName, ContextMethod, ReturnTypeWrapper, XmlDocSummary, HasKeyParam)
	var variants = new List<(string MethodName, string ContextMethod, string ReturnWrapper, string DocSummary, bool HasKeyParam)> {
		("AndGetAsync", "GetAsync", "{0}", "Accumulates a required single row query result", true),
		("AndGetOptionalAsync", "GetOptionalAsync", "Optional<{0}>", "Accumulates an optional single row query result (fails if more than one row)", false),
		("AndQueryOptionalAsync", "QueryOptionalAsync", "Optional<{0}>", "Accumulates the first row query result (takes first if multiple exist)", false),
		("AndQueryAnyAsync", "QueryAnyAsync", "IReadOnlyList<{0}>", "Accumulates a collection query result", false),
		("AndGetScalarAsync", "GetScalarAsync", "{0}", "Accumulates a scalar query result", false),
	};
#>
// <auto-generated/>
// Generated by DbResultTAccumulatorExtensions.tt
// Do not modify manually - changes will be overwritten.
#nullable enable

namespace Cirreum.Persistence;

using Cirreum;

/// <summary>
/// Provides extension methods for accumulating multiple query results into tuples.
/// These methods enable composing independent queries while preserving the railway-oriented
/// programming pattern, short-circuiting on the first failure.
/// </summary>
/// <remarks>
/// <para>
/// Use <c>AndXxxAsync</c> methods when queries are independent (don't need prior results for parameters).
/// Use <c>ThenXxxAsync</c> methods when a query depends on the result of a prior operation.
/// </para>
/// <para>
/// Example usage:
/// <code>
/// var result = await ctx.GetAsync&lt;User&gt;(userSql, userId)
///     .AndGetOptionalAsync&lt;Prefs&gt;(prefsSql)
///     .AndQueryAnyAsync&lt;Order&gt;(ordersSql)
///     .Map((user, prefs, orders) =&gt; new Dashboard(
///         user,
///         prefs.Map(p =&gt; p.Theme).GetValueOrDefault("default"),
///         orders));
/// </code>
/// </para>
/// </remarks>
public static class DbResultTAccumulatorExtensions {

<#
for (int n = 1; n < MaxTupleSize; n++)
{
	var currentType = TupleType(n);
	var currentTypeParams = n == 1 ? "T1" : TypeParams(n);
	var nextType = NextTypeParam(n);
	var decon = Deconstruct(n);
	var rebuild = BuildTuple(n);
	
	foreach (var (methodName, contextMethod, wrapperFormat, docSummary, hasKeyParam) in variants)
	{
		var wrappedNextType = string.Format(wrapperFormat, nextType);
		var fullResultType = $"({(n == 1 ? "T1" : TypeParams(n))}, {wrappedNextType})";
		var allTypeParams = $"{currentTypeParams}, {nextType}";
		var keyParamDecl = hasKeyParam ? ",\n        object key" : "";
		var keyParamPass = hasKeyParam ? ", key" : "";
		var keyParamDoc = hasKeyParam ? "\n    /// <param name=\"key\">A key associated with the query result, used in the NotFoundException if no row is found.</param>" : "";
		
		// Build typeparam docs for all type parameters
		var typeParamDocs = string.Join("\n    ", 
			Enumerable.Range(1, n).Select(i => $"/// <typeparam name=\"T{i}\">The type of element {i} in the source tuple.</typeparam>"))
			+ $"\n    /// <typeparam name=\"{nextType}\">The type of the value to accumulate.</typeparam>";
#>
	#region <#= methodName #>: <#= currentType #> -> <#= fullResultType #>

	/// <summary>
	/// <#= docSummary #> into the existing tuple.
	/// </summary>
	<#= typeParamDocs #>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param><#= keyParamDoc #>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<<#= fullResultType #>> <#= methodName #><<#= allTypeParams #>>(
		this DbResult<<#= currentType #>> first,
		string sql<#= keyParamDecl #>)
		=> new(first.Context, <#= methodName #>Core<<#= allTypeParams #>>(first.Result, first.Context, sql, null<#= keyParamPass #>));

	/// <summary>
	/// <#= docSummary #> into the existing tuple.
	/// </summary>
	<#= typeParamDocs #>
	/// <param name="first">The current result containing the accumulated tuple.</param>
	/// <param name="sql">The SQL query to execute.</param>
	/// <param name="parameters">An object containing the parameters to be passed to the SQL query.</param><#= keyParamDoc #>
	/// <returns>
	/// A <see cref="DbResult{T}"/> containing a tuple with the new value appended,
	/// or a failure if either the current result or the new query fails.
	/// </returns>
	public static DbResult<<#= fullResultType #>> <#= methodName #><<#= allTypeParams #>>(
		this DbResult<<#= currentType #>> first,
		string sql,
		object? parameters<#= keyParamDecl #>)
		=> new(first.Context, <#= methodName #>Core<<#= allTypeParams #>>(first.Result, first.Context, sql, parameters<#= keyParamPass #>));

	private static async Task<Result<<#= fullResultType #>>> <#= methodName #>Core<<#= allTypeParams #>>(
		Task<Result<<#= currentType #>>> resultTask,
		DbContext context,
		string sql,
		object? parameters<#= keyParamDecl #>) {

		var r1 = await resultTask.ConfigureAwait(false);
		if (r1.IsFailure) {
			return r1.Error;
		}

		var r2 = await context.<#= contextMethod #><<#= nextType #>>(sql, parameters<#= keyParamPass #>).Result.ConfigureAwait(false);
		if (r2.IsFailure) {
			return r2.Error;
		}

<# if (n == 1) { #>
		var v1 = r1.Value;
<# } else { #>
		var <#= decon #> = r1.Value;
<# } #>
		return (<#= rebuild #>, r2.Value);
	
	}

	#endregion

<#
	}
}
#>
}